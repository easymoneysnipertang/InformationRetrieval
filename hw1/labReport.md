# hw1
## 索引构建
索引构建主要由`BSBIIndex`类实现  
`BSBIIndex`类的主要成员函数有：
- `parse_block`：解析一个块，将其转换为倒排索引
- `invert_write`：将倒排索引写入磁盘
- `merge`：将多个倒排索引合并为一个
- `index`：索引构建的入口函数

在`index`函数中，首先调用`parse_block`函数解析每个块：  
具体实现上，顺序读入块内每个文件后，将文件内容进行去空格和分词，我所使用的分词方法是split函数，将分词后的termId存入`term_id_map`中，再与与docId一起构成二元组放入返回列表中  

接着转入`invert_write`函数，负责将二元组转成倒排索引并写入磁盘：  
首先对二元组进行排序，排序的依据是termId。然后顺序遍历二元组，将termId相同的docId放入一个posting_list中，直到遇见与当前termId不同的termId时，将倒排链表写入磁盘，而后开始为新termId构建倒排链表  
之所以能遇见新的termId即开始构建新的倒排链表，是因为在一开始已为二元组排过序，保证了termId是有序的  

写入磁盘调用的是`InvertedIndexWriter`的`append`函数，继承自`InvertedIndex`，是专门封装用于读写磁盘的类  
`append`函数将给定的倒排链表写入磁盘：首先对倒排链表进行编码压缩，而后记录该词项的**metadata**，包括在索引文件中的开始位置、倒排链表文档数、编码后的链表长度。metadata交由父类封装保存，自己调用`write`函数将编码后的倒排链表写入磁盘  

最后调用`merge`函数，将不同块的同一词项的多个倒排索引合并为一个：  
使用`heapq.merge`构建小根堆，将每个块的倒排索引的迭代器放入堆中，每次从堆中取出最小的元素，即最小的termId，将其倒排链表放入**写缓冲区**中，直到遇见新的termId，将缓冲区中的倒排链表去重排序后写入磁盘，接着开始为新termId构建  
每个块中的词项排布都是有序的，所以在取到与当前词项不同的词项时，可以说明各个块中的当前词项皆已被取出  
另外，查阅`heapq`的参考文档可以知道，`heapq.merge`不会一次性将所有块的倒排索引读入内存，而是在需要时才会读入，理论上维持了合理的**读缓冲区**  

`merge`函数使用的迭代器是继承自`InvertedIndex`的`InvertedIndexIterator`，实现上只需维护一个迭代位置，在取`next`时，通过位置获取到相应的词项，再通过`postings_dict`得到该词项的三元组信息，即前面保存的metada  
而后调整index文件指针读取一定量内容进行解码，即得到了词项对应的倒排链表


## 布尔检索
在`BSBIIndex`类里封装`retrieve`函数进行布尔检索  
首先对查询进行分词得到term，并获取其termId，通过`InvertedIndexMapper`的接口获取解码后的倒排链表，使用`sorted_intersect`进行求交集，最后返回所有term求交的结果  
`InvertedIndexMapper`是对`InvertedIndex`的继承，通过metadata读取index文件中的倒排链表，并进行解压缩  
`sorted_intersect`是使用**拉链法**实现的一个求交函数，顺序遍历两个有序链表求交集  


## 索引压缩
使用可变长编码对倒排链表进行压缩，`encode`函数顺序遍历链表，得到词项gap，并调用`vb_encode`对其进行编码  
`vb_encode`函数实现并不复杂，每次取出gap的低7位，字节最高位置1，加入字节列表，再将gap右移7位循环以上操作，直到gap为0，返回byte列表  

`decode`则是对`encode`的逆操作，将byte列表转换为gap列表，再将gap列表逐步规约为docId列表篇  
`vb_decode`遍历byte列表，解压gap。当读出的byte高位为1时，认为还没有访问到终点，gap左移，将byte低七位放入gap的低七位中。重复执行以上操作，直到byte高位为0时，byte放入gap后，该gap解压完毕，放入结果列表中，gap清零继续遍历  


## gamma编码
gamma编码在encode时首先获取gap去掉高位1后的长度，可以通过`log2`函数得到，若干1后加个0作为分割，再将gap的二进制补充在末尾，即可得到gamma编码  
实现上，很容易得到**字符串表示**的gamma编码，再使用int将二进制形式转换成十进制形式，接着转换成byte即可  

解码时，读取前缀1得到gap的长度，再读取相应长度的gap，在最高位加上1，即可得到原来的gap  
具体实现上，首先**逐字节**访问找到gap对应的字节列表：查看每个字节的位长（小的细节是，如果是第一次寻找byte则需特别计算有效位长，否则8个字节直接都是有效位），通过**掩码相与**的方式查看当前字节是否含0，若不含0则说明该字节仍然在描述gap的位长，进行累加  
若含0则说明当前字节已有部分是gap的位，将之前累加的位长转换为byte数，往后获取相应多个byte组成完整的字节列表  
有了字节列表，则可以在字节列表中进行解码得到真正的gap：计算gap占用的位数、字节数、在交接字节处占用的位数，而后即可逐步左移加上对应的位，得到gap  
得到所有gap后，进行一次规约求和即可得到解码后的倒排链表  

